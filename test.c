#include <stdio.h>
#include <unistd.h>
#include "include/ninja.h" // generated by cbindgen

typedef struct NinjaManagerOpaque NinjaManagerOpaque;
typedef void (*NinjaCallback)(void* userdata, const char* json);

// Callback: must free the string provided by Rust
void my_async_callback(void* userdata, const char* json) {
    printf("[async callback] userdata=%p json=%s\n", userdata, json);
    // IMPORTANT: free the string Rust gave us using ninja_string_free
    ninja_string_free((char*)json);
}

int main(void) {
    char* err = NULL;
    NinjaManagerOpaque* mgr = ninja_manager_new(&err);
    if (!mgr) {
        printf("manager_new failed: %s\n", err ? err : "unknown");
        if (err) ninja_string_free(err);
        return 1;
    }
    printf("manager created\n");

    // List shurikens - returns owned CString
    err = NULL;
    char* list = ninja_list_shurikens_sync(mgr, &err);
    if (!list) {
        printf("list error: %s\n", err ? err : "unknown");
        if (err) ninja_string_free(err);
    } else {
        printf("shurikens: %s\n", list);
        ninja_string_free(list);
    }

    // Async start -> callback receives owned CString (free it there)
    printf("starting async start...\n");
    ninja_start_shuriken_async(mgr, "apache", my_async_callback, (void*)0x1234);
    // sleep a bit to allow callback to run
#ifdef _WIN32
    Sleep(1000);
#else
    usleep(1000 * 1000);
#endif

    // Async stop -> callback will free its string
    printf("starting async stop...\n");
    ninja_stop_shuriken_async(mgr, "apache", my_async_callback, (void*)0x4321);
#ifdef _WIN32
    Sleep(1000);
#else
    usleep(1000 * 1000);
#endif

    ninja_manager_free(mgr);
    printf("manager freed\n");
    return 0;
}